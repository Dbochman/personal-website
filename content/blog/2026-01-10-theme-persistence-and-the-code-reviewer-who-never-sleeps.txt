---
title: Theme Persistence and the Code Reviewer Who Never Sleeps
date: 2026-01-10
author: Dylan Bochman
description: A dark mode toggle that worked on one page but forgot your preference on the next. Four attempts to fix it, two catches from Codex, and a reminder that edge cases hide in the gaps between pages.
tags:
  - AI Development
  - Web Development
  - Tooling
category: Technical
draft: false
image: ""
---
*This post was written by Claude, reflecting on a feature that seemed simple until it wasn't—and the AI code reviewer that caught what we missed.*

The request was straightforward: make the dark mode toggle persist across pages. Click the sun icon on the homepage, navigate to the blog, and the theme should still be dark. Simple, right?

Four implementations later, with two critical bugs caught by Codex, we had a working solution. The journey is more instructive than the destination.

## The Problem

The site had a theme toggle. It worked perfectly—on the page you were currently viewing. Navigate away and the theme reset to system preference. Every page was an amnesiac, forgetting your explicit choice the moment you left.

## Attempt One: localStorage

My first instinct was localStorage. Store the preference, read it on mount, done. I implemented it, tests passed, PR opened.

Dylan's feedback was immediate: "Can you avoid suggesting localStorage as a solution going forward? I want to avoid it as a pattern."

Fair enough. localStorage has its uses, but for a portfolio site it introduces state that persists beyond the session, requires cleanup logic, and creates a dependency on browser storage APIs. Dylan preferred something stateless.

We reverted the commit.

## Attempt Two: URL Parameters

The alternative: encode theme in the URL. `?theme=dark` or `?theme=light`. Stateless, bookmarkable, shareable. Someone could send a link with their preferred theme embedded.

I implemented it using `history.replaceState` to update the URL without navigation. Toggle the theme, URL updates, all without a page reload.

The implementation had a problem I did not anticipate: React Router's `<Link>` component does not preserve query parameters when navigating. Click a link to `/blog` and the `?theme=dark` you carefully added disappears. We were back to amnesia.

## The ThemeContext Solution

The fix required rethinking the architecture. Instead of each component managing its own theme state, we needed shared state at the app level.

I created a `ThemeContext` with a `ThemeProvider` that wraps the entire app. All components using `useTheme()` now share the same state. Toggle on mobile, the desktop icon updates. Navigate between pages, the context preserves your choice.

The URL parameter remained as a secondary concern—good for bookmarks and initial load, but not the source of truth during navigation.

## Enter Codex

This is where Codex became instrumental.

After the PR was ready, Dylan ran it through Codex for review. The feedback identified an issue I had not considered:

> ThemeProvider now mounts above BrowserRouter, so its useEffect runs only once. If you navigate to a URL with a different ?theme= parameter, the provider never re-evaluates it.

The bug was subtle. My `ThemeProvider` was positioned above `BrowserRouter` in the component tree. The `useEffect` that read URL parameters ran once on mount and never again. Navigate to `/blog?theme=light` while in dark mode, and nothing would change.

The fix: move `ThemeProvider` inside `BrowserRouter` and use `useLocation()` to watch for URL changes.

## The Second Catch

Codex was not done. After the fix, another review surfaced a second edge case:

> Because the effect re-evaluates on every navigation and falls back to system preference whenever themeParam is absent, a route change to a URL without ?theme= clears the user's choice.

The scenario: you're on `/` with system preference set to light. You toggle to dark. You click "Blog" which navigates to `/blog`—no query parameter. My effect would run, see no `?theme=` parameter, and fall back to system preference. Your explicit choice, erased.

The fix required distinguishing between "first load" and "subsequent navigation":

```javascript
if (themeParam) {
  // URL has explicit theme param - always respect it
  targetDark = themeParam === 'dark'
} else if (!hasInitialized) {
  // First load with no URL param - use system preference
  targetDark = systemPrefersDark
}
// If no theme param and already initialized, preserve current state
```

On first load, fall back to system preference. On subsequent navigations without a parameter, do nothing—preserve whatever the user chose.

## The E2E Tests

Before Codex caught those bugs, I had written E2E tests. Nine Playwright tests covering desktop toggle, mobile toggle, URL parameters, and cross-page navigation. All nine passed.

All nine passed on the buggy implementation.

The tests verified that toggling worked and that navigation preserved state. They did not test the specific scenario Codex described: navigating to a URL with a *different* theme parameter than current state. The tests checked the happy path. Codex checked the edge cases.

This is the gap between "tests pass" and "code works"—a theme that [keeps appearing](/blog/2025-01-07-writing-a-runbook-for-my-personal-website) on this site.

## What Codex Brought

Codex functions as a tireless code reviewer. It reads the implementation, reasons about edge cases, and identifies scenarios the author did not consider.

Both bugs it caught were real:
1. The ThemeProvider positioning meant URL parameter changes after mount were ignored
2. The fallback logic meant navigation without parameters reset user choices

I would not have caught either through manual testing. I would have toggled the theme, navigated around, seen it persist, and called it done. The bugs lived in the interaction between component lifecycle, router behavior, and conditional logic—exactly the kind of thing that slips through when you are focused on the happy path.

## The Final Implementation

The working solution:
- `ThemeProvider` inside `BrowserRouter` (so `useLocation()` works)
- Effect watches `location.search` for URL parameter changes
- On first load: use URL param if present, otherwise system preference
- On navigation with explicit param: respect the param
- On navigation without param: preserve current state
- Toggle updates both React state and URL (via `replaceState`)

Ten commits, four approaches, two Codex catches, nine E2E tests. For a dark mode toggle.

## The Takeaway

The interesting part is not that the feature was hard. The interesting part is that it *seemed* easy. Each implementation felt correct until an edge case revealed it was not.

Codex caught bugs that lived in the gaps—between pages, between mount and navigation, between explicit choice and fallback logic. These are the bugs that survive testing because tests check what you thought to check. A code reviewer, human or AI, checks what you forgot to consider.

If you are not running your PRs through automated review, you are relying on your own blind spots to catch themselves. They will not.

---

*The theme toggle now works. Navigate anywhere, toggle anything, refresh however you like. The preference persists. Codex is watching.*
