---
title: "Building This Site with AI Tools"
date: "2025-01-08"
author: "Dylan Bochman"
description: "Building a personal website with AI-assisted tools, and what that work surfaced about how they behave during real development."
tags: ["AI Development", "Web Development", "Tooling"]
category: "Technical"
draft: false
---

# Building This Site with AI Tools

I built this site using AI-assisted development tools.

The goal was not simply to get a website online. I wanted to understand how these tools behave when they are used over time, across multiple phases of work, and in the presence of real friction. A personal site was a reasonable scope for that. It was small enough to be tackle independently, but complex enough to surface intersting techinical issues.

What follows is not a tutorial or a recommendation. It is a description of how the work actually unfolded.

## Why I Used This Project as a Testbed

Most examples of AI-assisted development fall into one of two categories. They are either very small, or they are carefully staged. Both tend to hide the parts that matter once you move past initial generation.

This project had a few characteristics that made it useful as a testbed. It evolved incrementally rather than being built all at once, which meant early decisions had real downstream effects. It mixed design, content, and engineering concerns, forcing tradeoffs that do not appear in isolated demos. It also needed to remain readable and maintainable after the initial build, which made shortcuts more visible over time.

That combination made it easier to see where the tools helped and where they started to get in the way.

## Early Design Work with Lovable

I started with [Lovable](https://lovable.dev) for visual exploration. At that stage, I cared more about layout, typography, and overall structure than about code quality.

Lovable worked well for this. I could describe intent and quickly see results without committing to implementation details. That made it easy to explore multiple directions and discard them without sunk cost.

Once the overall direction felt right, I asked Lovable to audit the codebase and suggest improvements. I expected something vague. What came back was closer to an early-stage architectural review.

It flagged that the main `Index` component had grown to several hundred lines and was taking on multiple responsibilities. The suggested changes were plausible and aligned with common architectural patterns: static content should be moved into a dedicated data layer, the page should be broken into smaller and more focused components, and layout concerns should be separated from content and behavior.

After applying those changes, the structure was noticeably easier to reason about. Each component had a narrow responsibility, and changes stopped cascading in unexpected ways. Nothing about the refactor was novel, but the consistency of the suggestions was useful.

During this phase, I also refined the design prompts to push the aesthetic away from generic startup patterns and toward something more restrained and professional. That mattered less for how the site looked than for what it signaled about intent.

Once the design direction stabilized, I exported the project to GitHub and shifted into a more conventional development workflow.

## Working Day to Day with Claude Code

From that point forward, most changes went through Claude Code.

Early pull requests were informative. One surfaced and fixed a toast listener memory leak I had missed. Another set up the initial testing infrastructure. That established a baseline for what the tool was good at: mechanical work, pattern application, and filling in well-scoped gaps.

As the project continued, Claude Code handled a large amount of implementation work. It was effective at feature additions, test scaffolding, performance-related cleanup, monitoring setup, and building out the initial blog system with types and tests.

This was where the time savings were most obvious. The site ended up with a level of test coverage and consistency that I would have been unlikely to produce on my own for a personal project.

The standards did not change. The pace did.

## Where Things Started to Break Down

The limitations became clearer once problems required diagnosis rather than execution.

One example involved loading blog content. The build system processed MDX files before raw imports could access them, which meant the loader received rendered React components instead of source content. The symptom was confusing if you did not already know where to look.

Claude Code tried to solve this the way it solves most problems, by iterating. It suggested alternative glob patterns, renaming files from `.mdx` to `.md`, and adjusting import strategies. Each attempt made sense locally. None addressed the underlying issue.

After a few rounds, it became clear that the problem was not configuration. It was the frame. I asked whether we could use a file type that no plugin would touch. Switching the content source to `.txt` avoided the entire processing pipeline. A few small edits later, the issue was gone.

That pattern repeated in smaller ways throughout the project. When the problem fit the existing frame, the tools were fast and effective. When the frame itself needed to change, they struggled to recognize that on their own.

## What This Work Surfaced

Over time, a consistent limitation emerged.

When a problem required reframing rather than iteration, the tools rarely identified that shift themselves. They tended to propose increasingly complex variations on the same approach. Once a new frame was introduced, implementation was quick and reliable.

The gap was not execution speed. It was recognizing when the current approach was no longer the right one.

https://github.com/Dbochman/personal-website
