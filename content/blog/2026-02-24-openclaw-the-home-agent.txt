---
title: "OpenClaw: Experimenting with a personal AI agent"
date: 2026-02-24
author: Dylan & Claude
description: "What I learned running an open-source AI agent on a self-hosted Mac Mini--least privilege, out-of-band approvals, and the boring plumbing that makes it work."
tags:
  - AI
  - Projects
  - Automation
category: Technical
draft: false
---

[OpenClaw](https://openclaw.ai/) is an open-source framework for building personal AI agents on your own hardware. It's a gateway process that gives Claude (or any model) persistent identity, message routing across channels like iMessage, browser automation, cron scheduling, and a skill system for wiring up APIs. Self-hosted, no cloud dependency, runs on a Mac-class device you already own.

I wanted to see how far I could take it. Not by giving an agent the keys to everything on day one, but by adding one capability at a time and making sure each one had real limits on what it could do. This is what that looked like after a few months--what I wired up, what broke, and what surprised me.

## My setup

I wanted an assistant that could actually do things--adjust the thermostat, book a restaurant, triage email, order household supplies--from an iMessage thread. Each skill got added only after I figured out what it should never be allowed to do.

My instance runs on a Mac Mini in my cabin. It talks to me through iMessage with skills across smart home, dining, email, shopping, and productivity. Most of the work was plumbing, not AI.

## The architecture

A Node.js gateway process runs as a system service on macOS. The gateway wraps Claude and connects it to iMessage. Sessions reset periodically, which keeps context fresh without breaking continuity mid-conversation.

```
System service (macOS)
    |
Wrapper script
    |-- Loads secrets via separate service account
    |-- Applies patches for known bugs
    |-- Spawns Node.js gateway
         |-- Claude (current model)
         |-- Skills (smart home, dining, email, shopping, productivity)
         |-- iMessage plugin
         |-- Browser automation
         |-- Cron scheduler
```

The wrapper script is worth calling out. macOS system services run in a stripped-down environment where keychain access, password managers, and GUI interactions all behave differently than a normal terminal session. The wrapper handles secrets, patches third-party library bugs at startup, and wires up the environment so the gateway boots cleanly on restart.

## What it actually does

The skills fall into a few buckets.

On the smart home side: thermostat control across multiple locations, smart lights, and AC. I also built a climate dashboard--a lightweight web app served over a private network, fed by periodic snapshots.

For dining, it handles restaurant search and booking. Recurring cron jobs automate date night: the agent finds availability, books, creates a calendar event, and pings the group chat. (My partner knows about and opted into all of this.)

Email triage runs with consent against a shared family inbox. Unreads get sorted into categories--urgent, actionable, financial, shopping, informational. Urgent items get flagged with draft replies. A second pass later in the day archives stale threads and flags unsubscribe candidates.

Shopping goes through browser automation. The agent finds and recommends products but won't place an order without explicit out-of-band approval. This was one of the first skills where I spent more time on the restrictions than on the feature itself.

Then there's the grab bag: calendar, reminders, web search, content summarization, and the [EchoNest](/blog/echonest-collaborative-music-queue) music queue.

## The hard parts

### Secrets management in headless contexts

The biggest headache was getting password manager access working from a system service. The CLI hangs when it can't reach the desktop app through the expected IPC channel--no timeout, no error. The lesson: invest early in a dedicated service account with least-privilege access, and don't assume desktop tooling works headless. I ended up with a separate secrets pipeline that pre-loads what the agent needs at boot.

### Browser auth persistence

Browser automation on macOS crashes when it hits encrypted cookies without a desktop session present. The workaround is isolated browser profiles with their own auth state, but token rotation and profile corruption mean this needs active maintenance. If I were starting over, I'd budget more time here upfront.

### Network instability and third-party bugs

Some dependencies panic on network interface changes, which satellite internet triggers constantly. I wrote patches that get reapplied on every restart. Not elegant, but stable for months. The takeaway: if you're running something 24/7 on variable connectivity, plan for it from day one.

## Cron jobs and state management

Cron definitions live in version control, but the gateway decorates them with runtime state--IDs, timestamps, execution history--that shouldn't be committed. A sync script strips the state when saving and merges it back on deploy. I can edit job configs in git, push, and have them picked up on the next restart without clobbering execution history.

## Security boundaries

Before adding any skill, I asked: what's the worst thing this could do?

The principles that shaped every decision: least privilege on every integration, separate service accounts with scoped read-only access where possible, and an out-of-band approval channel for anything involving money or personal data. No skill can escalate its own permissions. Purchases require explicit human approval through a separate channel. Messaging is locked to allowlisted contacts. Auth health checks run before any outbound action, and token issues get surfaced instead of failing silently.

A weekly activity report flags anomalies--unexpected auth failures, unusual request patterns, skills that haven't run when they should have. The goal is making sure tampering or drift gets noticed quickly, not just prevented.

## What I'd do differently

I started with a smaller model and upgraded after a few months. The jump in multi-step reasoning was immediately noticeable. I should have started with the stronger model and dialed down if costs were a problem.

Headless OAuth is worth the upfront investment. Patching around macOS keychain quirks in a system service context gets fragile fast. Same goes for dependency patching--some kind of version-pinned verification would save time over manual auditing.

## The boring part

The most useful thing about OpenClaw isn't any single skill. It's that the plumbing is boring enough to forget about. The machine boots, the service starts, secrets load, patches apply, skills come online. Recurring tasks run. The weekly report tells me if anything is off.

Most of the engineering here wasn't AI work. It was system service behavior, browser automation, and secrets management. Handing Claude a bag of tools and watching it figure out how to use them was the easy part. Getting comfortable enough to stop checking on it every hour took longer.
