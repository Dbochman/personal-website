# Build Performance (Staged + Cached)

> Plan generated by Codex Architect

## Bottom Line

Split the build into a Node-based content prep stage followed by the existing Vite bundle, caching per-MDX artifacts under `.cache` so unchanged posts never re-render. Hash MDX inputs (content + frontmatter) to drive reuse and keep the pipeline npm-script friendly without touching CI structure.

## Action Plan

### 1. Add Two-Stage Build Scripts

Update `package.json`:

```json
{
  "scripts": {
    "build": "npm run build:content && npm run build:vite",
    "build:content": "tsx scripts/build-content.ts",
    "build:vite": "vite build"
  }
}
```

### 2. Implement Content Build Script

Create `scripts/build-content.ts`:

```typescript
import { glob } from 'glob';
import { createHash } from 'crypto';
import { readFileSync, writeFileSync, existsSync } from 'fs';

interface ManifestEntry {
  path: string;
  hash: string;
  slug: string;
  generatedPath: string;
}

// Discover MDX files
const mdxFiles = await glob('content/blog/**/*.mdx');

// Load existing manifest
const manifest = existsSync('.cache/mdx/manifest.json')
  ? JSON.parse(readFileSync('.cache/mdx/manifest.json', 'utf-8'))
  : [];

for (const file of mdxFiles) {
  const content = readFileSync(file, 'utf-8');
  const hash = createHash('sha256').update(content).digest('hex');

  const cached = manifest.find(e => e.path === file && e.hash === hash);

  if (cached) {
    // Cache hit: copy from .cache to src/generated
    copySync(cached.generatedPath, `src/generated/posts/${cached.slug}.json`);
  } else {
    // Cache miss: process MDX
    const result = await processMdx(file);
    writeFileSync(`src/generated/posts/${result.slug}.json`, JSON.stringify(result));
    writeFileSync(`.cache/mdx/${hash}.json`, JSON.stringify(result));
    updateManifest(file, hash, result.slug);
  }
}

// Clean stale generated files
cleanStaleFiles(manifest, mdxFiles);
```

### 3. Cache Directory Structure

```
.cache/
  mdx/
    manifest.json        # [{path, hash, slug, generatedPath}]
    <hash>.json          # cached rendered payload for that MDX
  meta.json              # version/schema marker for invalidation

src/generated/
  posts/
    <slug>.json
  content-index.json     # aggregation written by build-content
```

Invalidate cache if `meta.json` mismatches current schema/version.

### 4. Update Vite Configuration

Update content imports to read from `src/generated` artifacts:
- No MDX compilation at bundle time
- Consume generated index or per-post JSON

### 5. CI Cache Integration

Persist `.cache/mdx` between CI runs:

```yaml
- uses: actions/cache@v4
  with:
    path: .cache/mdx
    key: mdx-cache-${{ hashFiles('content/blog/**/*.mdx') }}
    restore-keys: |
      mdx-cache-
```

## Effort Estimate

**Medium** (1-2 days)

## Success Criteria

- [ ] Two-stage build working locally
- [ ] Unchanged MDX files skip reprocessing
- [ ] CI benefits from cache across runs
- [ ] Build time reduced for incremental changes
